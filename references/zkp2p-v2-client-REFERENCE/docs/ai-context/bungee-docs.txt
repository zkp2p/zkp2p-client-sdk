Introduction
Bungeeâ€™s unified API makes cross-chain token swaps simple. This page walks you through the integration process and helps you choose the right approach for your app.

Integration flow
Integrating Bungee Auto involves 4 steps:

Get a quote: Fetch quote pricing information
Create a Request: Prepare the request
Submit a Request: Submit the request either via the submit endpoint or onchain via the Inbox Contract
Monitor status: Track the Request status
And that's it! Bungee Auto will handle the rest. See our integration guides for step-by-step instructions on how to integrate Bungee into your application.

Bungee Link
Redirect users to Bungee with chain/tokens for bridging pre-selected. The bridging amount can also be pre-selected. Users then simply need to choose a route & start bridging with 2 clicks! You can link Bungee in your DApp and pass URL params to specify which chains/tokens should be pre-selected for bridging. The parameters are highlighted below:

Parameter	Description
fromChainId	Chain ID of sending chain
fromTokenAddress	Address of sending token
toChainId	Chain ID of destination chain
toTokenAddress	Address of destination receiving token
Examples:
ETH from Ethereum to USDC on Optimism:

https://bungee.exchange/?fromChainId=1&fromTokenAddress=0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee&toChainId=10&toTokenAddress=0x0b2c639c533813f4aa9d7837caf62653d097ff85


USDC from Polygon to Aave on Arbitrum:

https://bungee.exchange/?fromChainId=137&fromTokenAddress=0x3c499c542cef5e3811e1192ce70d8cc03d5c3359&toChainId=42161&toTokenAddress=0xba5ddd1f9d7f570dc94a51479a000e3bce967196


Integration Tips
For native tokens (ETH, MATIC, etc.), use the address 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
Chain IDs follow the standard EVM chain ID format (e.g., 1 for Ethereum, 10 for Optimism)
Previous
Introduction

Overview
This guide provides a step-by-step overview of integrating Bungee Auto into your application.

Integration Flow
All Bungee integrations follow the four key steps below. For detailed API specifications, see the API Reference.

1. Get a quote
Request a quote from the /bungee/quote endpoint to receive available routes, fee estimates, and transaction data for your token swap.

2. Handle token approvals
For ERC20 tokens only:

Auto Mode: Uses Permit2 for gasless approvals (Permit2 tx data is provided in the quote response)
Manual Mode: Requires standard ERC20 approval transaction (approval transaction data is provided in the quote response and execution data in the build-tx response)
3. Submit the transaction (onchain or gasless)
Auto ERC20

Sign the Permit2 typed data and submit it offchain via /bungee/submit endpoint

info
See submit onchain requests to get the transaction data in the quote response and submit ERC20 requests onchain

Auto Native Token

Transaction data is provided in the quote response
Submit the request onchain to the Inbox Contract
Manual Routes

Build transaction data via /bungee/build-tx endpoint and submit onchain

4. Monitor the transaction status
API Endpoint: /bungee/status
Track the status of your transaction until completion.

Submit requests with Permit2
Integrate Bungee with Permit2 for ERC20 tokens

Submit requests onchain
Integrate Bungee with the Inbox Contract

API Base URL
The Bungee Auto API is available at:

https://public-backend.bungee.exchange

All API endpoints use this base URL. For details, see the API Reference.

This public endpoint is available for development and testing with a rate limit of 20 requests per minute (RPM). No authentication is required for the public endpoint.

Requesting Production API Access
For production use with higher rate limits, please fill out the Bungee API access request form to request dedicated API keys and access to our production endpoint.

Submission Methods
Bungee Auto requests can be submitted in two ways:

Gasless request with Permit2
This method uses the Bungee Auto API with Permit2 for gasless approvals:

Get a quote from the Bungee API
Create a request via the API
Approve Permit2 contract if needed
Sign a Permit2 message
Submit the request with the signature
Monitor the status via the API
This is the recommended approach for ERC20 tokens as it provides a better user experience by eliminating the need for separate approval transactions. Additionally, it allows for gasless approvals, saving users gas fees and tokens are only transferred if the auction is completed and a transmitter has picked up the request.

For a complete implementation guide, see Permit2 Integration (ERC20).

Inbox Contract
This method uses the Bungee Auto inbox contract to directly submit the request onchain:

Get a quote from the Bungee API
Create and submit a request onchain via Inbox contract
Monitor the status via the API
This method is required for native tokens (ETH, MATIC, etc.) and can also be used for ERC20 tokens if Permit2 is not an option or if the integration is directly onchain.

For a complete implementation guide, see onchain request submission via Inbox Contract.

Token list and search
info
Bungee Auto supports trading any token with sufficient liquidity, regardless of whether it appears in the token list responses.

Token Sources and Verification
Bungee maintains a primary data source for token information and categorizes tokens in two ways:

Verified Tokens: These are recognized by Bungee and are considered verified.
Unverified Tokens: These are tokens added to our own database that may not be widely listed yet. When these are displayed, we recommend showing a warning to users to exercise caution.
We may add more sources in the future to further expand our token coverage.

How the Endpoints and Parameters Work
/tokens/list (Default):

Returns a curated list of trending tokens, all of which are "verified" (recognized by Bungee).
"Trending" is currently determined by trading volume, showing the tokens with the highest volume on each supported network.
This list is dynamic, and the trending algorithm may evolve to include other factors for relevance.
/tokens/list (with list=full parameter):

Returns the full, unabridged list of all tokens known to Bungee (including both verified and unverified tokens).
Warning: This is a very heavy and slow API call. We strongly recommend not using it in a production frontend application.
/tokens/search:

Designed to find a specific token by its name, symbol, or address (e.g., "USDC").
Searches across the entire dataset, including both verified and unverified tokens.
Best Practices
For the best user experience, we recommend:
Using the default /tokens/list to display a relevant, curated list of trending tokens.
Maintaining your own list of tokens that are most relevant to your users.
Most tokens with sufficient liquidity should return a valid route through Bungee, regardless of which list they appear on.
Token list endpoint example usage
The /tokens/list endpoint retrieves a list of available tokens, with optional parameters to customize the response.

API Reference: Token List Endpoint

const BUNGEE_API_BASE_URL = "https://public-backend.bungee.exchange";

async function getTokenList(userAddress, chainIds = [1], isTrending = true) {
  const url = `${BUNGEE_API_BASE_URL}/api/v1/tokens/list`;
  const params = {
    userAddress,
    chainIds: chainIds.join(","),
    list: isTrending ? "trending" : "full",
  };

  const queryParams = new URLSearchParams(params);
  const response = await fetch(`${url}?${queryParams}`);
  const data = await response.json();

  return data;
}

Token search endpoint example usage
The /tokens/search endpoint allows you to search for tokens by address, name, or symbol. Use this endpoint to verify if a specific token can be traded, even if it doesn't appear in the token list.

API Reference: Token Search Endpoint

async function searchToken(query, userAddress) {
  const url = `${BUNGEE_API_BASE_URL}/api/v1/tokens/search`;
  const params = {
    q: query,
    userAddress,
  };

  const queryParams = new URLSearchParams(params);
  const response = await fetch(`${url}?${queryParams}`);
  const data = await response.json();

  return data;
}

Complete Integration Example
import { privateKeyToAccount } from "viem/accounts";

const account = privateKeyToAccount(process.env.PRIVATE_KEY);
console.log("Account address:", account.address);

const BUNGEE_API_BASE_URL = "https://public-backend.bungee.exchange";

// Search for a token (by address, symbol, or name)
async function tokenSearch(query, userAddress) {
  try {
    const url = `${BUNGEE_API_BASE_URL}/api/v1/tokens/search`;
    const params = {
      q: query,
      userAddress,
    };

    const queryParams = new URLSearchParams(params);
    const response = await fetch(`${url}?${queryParams}`);
    const data = await response.json();
    const serverReqId = response.headers.get("server-req-id");

    if (!data.success) {
      throw new Error(
        `Search error: ${data.statusCode}: ${data.message}. server-req-id: ${serverReqId}`
      );
    }

    return {
      result: data.result,
      serverReqId,
    };
  } catch (error) {
    console.error("Failed to search for token:", error);
    throw error;
  }
}

// Get token list (trending or complete)
async function tokenList({
  userAddress = "",
  chainIds = [],
  isTrending = null,
} = {}) {
  try {
    const url = `${BUNGEE_API_BASE_URL}/api/v1/tokens/list`;
    const params = {};

    // Only add parameters if they have values
    if (userAddress) {
      params.userAddress = userAddress;
    }

    if (chainIds && chainIds.length > 0) {
      params.chainIds = chainIds.join(",");
    }

    // Only add list parameter if isTrending is explicitly specified
    if (isTrending !== null) {
      params.list = isTrending ? "trending" : "complete";
    }

    const queryParams = new URLSearchParams(params);
    const response = await fetch(`${url}?${queryParams}`);
    const data = await response.json();
    const serverReqId = response.headers.get("server-req-id");

    if (!data.success) {
      throw new Error(
        `List error: ${data.statusCode}: ${data.message}. server-req-id: ${serverReqId}`
      );
    }

    return {
      result: data.result,
      serverReqId,
    };
  } catch (error) {
    console.error("Failed to get token list:", error);
    throw error;
  }
}

// Usage examples
(async () => {
  try {
    let searchResponse;
    // Search for USDC
    searchResponse = await tokenSearch("USDC", account.address);
    console.log(
      "Search results:",
      JSON.stringify(searchResponse.result, null, 2)
    );

    // Search for a token address
    searchResponse = await tokenSearch(
      "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",
      account.address
    );
    console.log(
      "Search results:",
      JSON.stringify(searchResponse.result, null, 2)
    );

    // Search for a partial token name
    searchResponse = await tokenSearch("Bridged USD Coin", account.address);
    console.log(
      "Search results:",
      JSON.stringify(searchResponse.result, null, 2)
    );

    // Search for a inexisting token
    searchResponse = await tokenSearch("0x123...abc", account.address);
    if (Object.keys(searchResponse.result.tokens).length === 0) {
      console.log(
        "The tokens object is empty, but you can still try to trade this token if it has liquidity"
      );
    }

    let trendingResponse;
    // Get trending tokens on Ethereum and Arbitrum
    trendingResponse = await tokenList({
      userAddress: account.address,
      chainIds: [1, 42161],
      isTrending: true,
    });
    console.log(
      "Trending tokens:",
      JSON.stringify(trendingResponse.result, null, 2)
    );

    // Get complete token list for Optimism with account balances
    trendingResponse = await tokenList({
      userAddress: account.address,
      chainIds: [10],
      isTrending: false,
    });
    console.log(
      "Complete token list:",
      JSON.stringify(trendingResponse.result, null, 2)
    );

    // Get complete token list with account balances
    trendingResponse = await tokenList({ userAddress: account.address });
    console.log(
      "Complete token list:",
      JSON.stringify(trendingResponse.result, null, 2)
    );

    // Get trending token list for Optimism
    trendingResponse = await tokenList({ chainIds: [10] });
    console.log(
      "Trending token list for Optimism:",
      JSON.stringify(trendingResponse.result, null, 2)
    );

    // Get complete token list
    trendingResponse = await tokenList({ isTrending: false });
    console.log(
      "Complete token list:",
      JSON.stringify(trendingResponse.result, null, 2)
    );

    // Get trending token list for all chains
    trendingResponse = await tokenList();
    console.log(
      "Default token list:",
      JSON.stringify(trendingResponse.result, null, 2)
    );
  } catch (error) {
    console.error("Error:", error.message);
  }
})();

 Polygon USDC (Solana/web3.js)
import * as solanaWeb3 from '@solana/web3.js';
import { getAddressLookupTableAccounts } from '@mayanfinance/swap-sdk';
import fs from 'fs';
import path from 'path';
import os from 'os';
import dotenv from 'dotenv';
dotenv.config();

const keyPath = path.join(os.homedir(), '.config', 'solana', 'id.json');
const KEY = JSON.parse(fs.readFileSync(keyPath, 'utf-8'));

// Environment variables
const SOLANA_WALLET_ADDRESS = process.env.SOLANA_WALLET_ADDRESS;
const EVM_WALLET_ADDRESS = process.env.EVM_WALLET_ADDRESS;

// API Information - Updated to Bungee API
const BUNGEE_API_BASE_URL = 'https://public-backend.bungee.exchange';

// Token Addresses
const SOLANA_TOKEN_ADDRESS = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'; // native
const POLYGON_USDC = '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359';

// Transaction Parameters
const SWAP_AMOUNT = '50000000';
const FROM_CHAIN_ID = '89999'; // Solana chain ID
const TO_CHAIN_ID = '137'; // Polygon chain ID

async function getQuote() {
  const params = {
    userAddress: SOLANA_WALLET_ADDRESS,
    receiverAddress: EVM_WALLET_ADDRESS,
    originChainId: FROM_CHAIN_ID,
    destinationChainId: TO_CHAIN_ID,
    inputToken: SOLANA_TOKEN_ADDRESS,
    outputToken: POLYGON_USDC,
    inputAmount: SWAP_AMOUNT,
    enableManual: true, // Enable manual routes
  };

  try {
    const url = `${BUNGEE_API_BASE_URL}/api/v1/bungee/quote`;
    const queryParams = new URLSearchParams(params);
    const fullUrl = `${url}?${queryParams}`;
    console.log(fullUrl);

    const response = await fetch(fullUrl);
    const data = await response.json();

    if (!data.success) {
      throw new Error(`Quote error: ${data.error?.message || "Unknown error"}`);
    }

    // Check if manual routes are available
    if (!data.result.manualRoutes || data.result.manualRoutes.length === 0) {
      throw new Error("No manual routes available for this bridge");
    }

    // Select the first manual route
    const selectedRoute = data.result.manualRoutes[0];
    console.log("Selected manual route:", selectedRoute.quoteId);
    console.log("Expected Output Amount:", selectedRoute.output.amount);

    await getbuildtx(selectedRoute.quoteId);
  } catch (error) {
    console.error('Failed to get quote:', error);
    throw error;
  }
}

async function getbuildtx(quoteId) {
  try {
    console.log("Building transaction for quote ID:", quoteId);

    // Build transaction using quoteId parameter
    const url = `${BUNGEE_API_BASE_URL}/api/v1/bungee/build-tx?quoteId=${quoteId}`;
    const response = await fetch(url);
    const data = await response.json();

    if (!data.success) {
      throw new Error(`Build transaction error: ${data.error?.message || "Unknown error"}`);
    }

    const txData = data.result.txData;

    const clientInstructions = txData.instructions.map(
      (instruction) =>
        new solanaWeb3.TransactionInstruction({
          programId: new solanaWeb3.PublicKey(instruction.programId),
          keys: instruction.keys.map((key) => ({
            pubkey: new solanaWeb3.PublicKey(key.pubkey),
            isSigner: key.isSigner,
            isWritable: key.isWritable,
          })),
          data: Buffer.from(instruction.data),
        }),
    );

    const solanaConnection = new solanaWeb3.Connection(
      solanaWeb3.clusterApiUrl('mainnet-beta'),
    );

    const clientLookupTables = await getAddressLookupTableAccounts(
      txData.lookupTables,
      solanaConnection,
    );

    const _signers = txData.signers.map((signer) =>
      solanaWeb3.Keypair.fromSecretKey(Uint8Array.from(signer)),
    );

    const feePayer = new solanaWeb3.PublicKey(SOLANA_WALLET_ADDRESS);
    const { blockhash, lastValidBlockHeight } =
      await solanaConnection.getLatestBlockhash('finalized');

    const message = solanaWeb3.MessageV0.compile({
      instructions: clientInstructions,
      payerKey: feePayer,
      recentBlockhash: blockhash,
      addressLookupTableAccounts: clientLookupTables,
    });
    const transaction = new solanaWeb3.VersionedTransaction(message);
    transaction.sign(_signers);

    const privateKey = Uint8Array.from(KEY);
    const keypair = solanaWeb3.Keypair.fromSecretKey(privateKey);
    transaction.recentBlockhash = blockhash;
    transaction.feePayer = keypair.publicKeys
    transaction.sign([keypair]);

    const fee = await transaction.getEstimatedFee(solanaConnection);

    // Convert lamports to SOL
    const feeInSol = fee / solanaWeb3.LAMPORTS_PER_SOL;

    const signature = await solanaConnection.sendRawTransaction(
      transaction.serialize(),
      {
        skipPreflight: false,
        preflightCommitment: 'confirmed',
      },
    );

    // Optional: Wait for confirmation
    const confirmation = await solanaConnection.confirmTransaction({
      signature,
      blockhash: blockhash,
      lastValidBlockHeight: lastValidBlockHeight,
    });

    if (confirmation.value.err) {
      throw new Error(`Transaction failed: ${confirmation.value.err}`);
    }
    console.log({ signature });

    return signature;
  } catch (error) {
    console.error('Failed to build and send transaction:', error);
    throw error;
  }
}

(async () => {
  await getQuote();
})();

Swap across EVM & Solana
Bungee also supports swap assets from any EVM chain to Solana and from Solana to any EVM chain.

This guide walks you through swapping assets between EVM chains and Solana using Bungee. It covers supported chains, transaction options, and current limitations.

Quick Start
Solana Chain ID on Bungee API
The chain ID for Solana queries is 89999.

Key differences
Here's what's different when integrating Solana Bungee API compared to standard EVM chains:

Transaction Flow

No token approvals are needed on Solana
API Behavior

Both userAddress and recipient required for quotes
Fee collection only works for EVM â†’ Solana direction
Token Support

Any supported token can be sent TO Solana
Only specific tokens (ETH, USDC, USDT) can be received when bridging TO EVM
Special Token Address Handling
Supported chains
Currently, these chains are supported to bridge between EVM and Solana:

Ethereum
Optimism
Arbitrum
Polygon
Base
Avalanche
Binance Smart Chain
info
This chain list is for reference only.

Single Transaction Bridging
Bungee enables cross-chain swaps in a single transaction between Solana and EVM chains. But the direction of swaps and support determine which assets are supported:

EVM â†’ Solana: Swap any supported token to Solana
Solana â†’ EVM: Swap any supported token to specific EVM tokens only:
ETH on Ethereum, Optimism, Arbitrum and Base
USDC on all supported chains
USDT on Binance Smart Chain (BSC)
Integration Steps
The "Bungee Manual" guide from Bungee Docs outlines how to integrate a bridging process that allows users to swap and bridge tokens across chains in a single transaction on the source chain, eliminating the need for any transactions on the destination chain. This same process should be implemented when bridging to Solana.

Select Chains: Users choose the source and destination chains, which determine the tokens available for bridging.
Fetch Routes: After selecting the tokens, retrieve possible bridging routes using the /quote endpoint.
Token Approval: For ERC-20 tokens, users must grant permission for the protocol to spend their tokens.
Build Transaction: Obtain the transaction data from the /build-tx endpoint. Use this data to execute the bridging transaction on the source chain.
Track Transaction Status: Monitor the transaction's progress by polling the /status endpoint until the bridging process is complete.
info
For Solana quotes, please ensure both userAddress and recipient are defined.

Also, remember Solana does not require token approvals.

Examples
Queries
Quote from Base USDC to Solana TRUMP
https://public-backend.bungee.exchange/api/v1/bungee/quote?userAddress=0x3e8cB4bd04d81498aB4b94a392c334F5328b237b&originChainId=8453&destinationChainId=89999&inputAmount=100000000&inputToken=0x833589fcd6edb6e08f4c7c32d4f71b54bda02913&enableManual=true&receiverAddress=7BchahMyqpBZYmQS3QnbY3kRweDLgPCRpWdo1rxWmJ3g&refuel=false&outputToken=6p6xgHyF7AeE6TZkSmFsko444wqoP15icUSqi2jfGiPN

Find the MELANIA token on Solana with user balance
Querying the Solana RPC directly is recommended, notheless the current API supports:

https://public-backend.bungee.exchange/api/v1/tokens/search?q=FUAfBo2jgks6gB4Z4LfZkqSZgzNucisEHqnNebaRxM1P&userAddress=7BchahMyqpBZYmQS3QnbY3kRweDLgPCRpWdo1rxWmJ3g

Check trending tokens on Solana
https://public-backend.bungee.exchange/api/v1/tokens/list?chainIds=89999&list=trending

Scripts
Quote and swap from Base USDC to Solana SOL (Viem)
import { createPublicClient, createWalletClient, http } from 'viem';
import { base } from 'viem/chains';
import { privateKeyToAccount } from 'viem/accounts';
import dotenv from 'dotenv';
dotenv.config();

// Environment variables
const SOLANA_WALLET_ADDRESS = process.env.SOLANA_WALLET_ADDRESS;
const EVM_WALLET_ADDRESS = process.env.EVM_WALLET_ADDRESS;
const EVM_PRIVATE_KEY = process.env.EVM_PRIVATE_KEY;

// API information
const BUNGEE_API_BASE_URL = 'https://public-backend.bungee.exchange';
const BASE_RPC_URL = 'https://base.drpc.org';

// Contract Addresses
const SOLANA_TOKEN_ADDRESS = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'; // native
const BASE_USDC = '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913';

// Transaction details
const TX_GAS_LIMIT = 420000n;
const SWAP_AMOUNT = 100000000n;

// ERC-20 Approval ABI
const erc20Abi = [
  {
    name: 'approve',
    type: 'function',
    inputs: [
      { name: 'spender', type: 'address' },
      { name: 'amount', type: 'uint256' }
    ],
    outputs: [{ type: 'bool' }]
  }
];

async function getQuote() {
  const params = {
    userAddress: EVM_WALLET_ADDRESS,
    originChainId: 8453, // Base
    destinationChainId: 89999, // Bungee Solana chain ID
    inputAmount: SWAP_AMOUNT.toString(),
    inputToken: BASE_USDC,
    enableManual: true, // Enable manual routes
    receiverAddress: SOLANA_WALLET_ADDRESS,
    refuel: false,
    outputToken: SOLANA_TOKEN_ADDRESS,
  };

  try {
    const url = `${BUNGEE_API_BASE_URL}/api/v1/bungee/quote`;
    const queryParams = new URLSearchParams(params);
    const fullUrl = `${url}?${queryParams}`;

    const response = await fetch(fullUrl);
    const data = await response.json();

    if (!data.success) {
      throw new Error(`Quote error: ${data.error?.message || "Unknown error"}`);
    }

    // Check if manual routes are available
    if (!data.result.manualRoutes || data.result.manualRoutes.length === 0) {
      throw new Error("No manual routes available for this bridge");
    }

    // Select the first manual route
    const selectedRoute = data.result.manualRoutes[0];
    console.log("Selected manual route:", selectedRoute.quoteId);
    console.log("Expected Output Amount:", selectedRoute.output.amount);

    await buildAndSendTx(selectedRoute.quoteId, selectedRoute.approvalData);
  } catch (error) {
    console.error('Failed to get quote:', error);
    throw error;
  }
}

async function buildAndSendTx(quoteId, approvalData) {
  try {
    console.log("Building transaction for quote ID:", quoteId);

    // Build transaction using quoteId parameter
    const url = `${BUNGEE_API_BASE_URL}/api/v1/bungee/build-tx?quoteId=${quoteId}`;
    const response = await fetch(url);
    const data = await response.json();

    if (!data.success) {
      throw new Error(`Build transaction error: ${data.error?.message || "Unknown error"}`);
    }

    const txData = data.result.txData;

    // Create Viem clients
    const publicClient = createPublicClient({
      chain: base,
      transport: http(BASE_RPC_URL)
    });

    const account = privateKeyToAccount(`0x${EVM_PRIVATE_KEY}`);

    const walletClient = createWalletClient({
      account,
      chain: base,
      transport: http(BASE_RPC_URL)
    });

    // Get gas price
    const gasPrice = await publicClient.getGasPrice();

    // Handle token approval if needed
    if (approvalData) {
      console.log("Token approval required");

      try {
        const approveTx = await walletClient.writeContract({
          address: approvalData.tokenAddress,
          abi: erc20Abi,
          functionName: 'approve',
          args: [
            approvalData.spenderAddress,
            BigInt(approvalData.amount)
          ],
          gasPrice,
          gas: TX_GAS_LIMIT
        });

        console.log('Approval Transaction sent! Hash:', approveTx);

        // Wait for transaction confirmation
        const approvalReceipt = await publicClient.waitForTransactionReceipt({
          hash: approveTx
        });
        console.log('Approval successful!', approvalReceipt);
      } catch (error) {
        console.error('Error during approval:', error);
        return;
      }
    }

    // Send bridge transaction
    try {
      const bridgeTx = await walletClient.sendTransaction({
        to: txData.to,
        data: txData.data,
        value: BigInt(txData.value || "0"),
        gasPrice,
        gas: TX_GAS_LIMIT
      });

      console.log('Bridge Transaction sent. Hash:', bridgeTx);

      // Wait for transaction confirmation
      const receipt = await publicClient.waitForTransactionReceipt({
        hash: bridgeTx
      });
      console.log('Bridge Transaction confirmed:', receipt);
    } catch (error) {
      console.error('Error during bridge transaction:', error);
    }
  } catch (error) {
    console.error('Failed to build and send transaction:', error);
    throw error;
  }
}

(async () => {
  await getQuote();
})();

Quote and swap from Solana SOL to Polygon USDC (Solana/web3.js)
import * as solanaWeb3 from '@solana/web3.js';
import { getAddressLookupTableAccounts } from '@mayanfinance/swap-sdk';
import fs from 'fs';
import path from 'path';
import os from 'os';
import dotenv from 'dotenv';
dotenv.config();

const keyPath = path.join(os.homedir(), '.config', 'solana', 'id.json');
const KEY = JSON.parse(fs.readFileSync(keyPath, 'utf-8'));

// Environment variables
const SOLANA_WALLET_ADDRESS = process.env.SOLANA_WALLET_ADDRESS;
const EVM_WALLET_ADDRESS = process.env.EVM_WALLET_ADDRESS;

// API Information - Updated to Bungee API
const BUNGEE_API_BASE_URL = 'https://public-backend.bungee.exchange';

// Token Addresses
const SOLANA_TOKEN_ADDRESS = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'; // native
const POLYGON_USDC = '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359';

// Transaction Parameters
const SWAP_AMOUNT = '50000000';
const FROM_CHAIN_ID = '89999'; // Solana chain ID
const TO_CHAIN_ID = '137'; // Polygon chain ID

async function getQuote() {
  const params = {
    userAddress: SOLANA_WALLET_ADDRESS,
    receiverAddress: EVM_WALLET_ADDRESS,
    originChainId: FROM_CHAIN_ID,
    destinationChainId: TO_CHAIN_ID,
    inputToken: SOLANA_TOKEN_ADDRESS,
    outputToken: POLYGON_USDC,
    inputAmount: SWAP_AMOUNT,
    enableManual: true, // Enable manual routes
  };

  try {
    const url = `${BUNGEE_API_BASE_URL}/api/v1/bungee/quote`;
    const queryParams = new URLSearchParams(params);
    const fullUrl = `${url}?${queryParams}`;
    console.log(fullUrl);

    const response = await fetch(fullUrl);
    const data = await response.json();

    if (!data.success) {
      throw new Error(`Quote error: ${data.error?.message || "Unknown error"}`);
    }

    // Check if manual routes are available
    if (!data.result.manualRoutes || data.result.manualRoutes.length === 0) {
      throw new Error("No manual routes available for this bridge");
    }

    // Select the first manual route
    const selectedRoute = data.result.manualRoutes[0];
    console.log("Selected manual route:", selectedRoute.quoteId);
    console.log("Expected Output Amount:", selectedRoute.output.amount);

    await getbuildtx(selectedRoute.quoteId);
  } catch (error) {
    console.error('Failed to get quote:', error);
    throw error;
  }
}

async function getbuildtx(quoteId) {
  try {
    console.log("Building transaction for quote ID:", quoteId);

    // Build transaction using quoteId parameter
    const url = `${BUNGEE_API_BASE_URL}/api/v1/bungee/build-tx?quoteId=${quoteId}`;
    const response = await fetch(url);
    const data = await response.json();

    if (!data.success) {
      throw new Error(`Build transaction error: ${data.error?.message || "Unknown error"}`);
    }

    const txData = data.result.txData;

    const clientInstructions = txData.instructions.map(
      (instruction) =>
        new solanaWeb3.TransactionInstruction({
          programId: new solanaWeb3.PublicKey(instruction.programId),
          keys: instruction.keys.map((key) => ({
            pubkey: new solanaWeb3.PublicKey(key.pubkey),
            isSigner: key.isSigner,
            isWritable: key.isWritable,
          })),
          data: Buffer.from(instruction.data),
        }),
    );

    const solanaConnection = new solanaWeb3.Connection(
      solanaWeb3.clusterApiUrl('mainnet-beta'),
    );

    const clientLookupTables = await getAddressLookupTableAccounts(
      txData.lookupTables,
      solanaConnection,
    );

    const _signers = txData.signers.map((signer) =>
      solanaWeb3.Keypair.fromSecretKey(Uint8Array.from(signer)),
    );

    const feePayer = new solanaWeb3.PublicKey(SOLANA_WALLET_ADDRESS);
    const { blockhash, lastValidBlockHeight } =
      await solanaConnection.getLatestBlockhash('finalized');

    const message = solanaWeb3.MessageV0.compile({
      instructions: clientInstructions,
      payerKey: feePayer,
      recentBlockhash: blockhash,
      addressLookupTableAccounts: clientLookupTables,
    });
    const transaction = new solanaWeb3.VersionedTransaction(message);
    transaction.sign(_signers);

    const privateKey = Uint8Array.from(KEY);
    const keypair = solanaWeb3.Keypair.fromSecretKey(privateKey);
    transaction.recentBlockhash = blockhash;
    transaction.feePayer = keypair.publicKey;
    transaction.sign([keypair]);

    const fee = await transaction.getEstimatedFee(solanaConnection);

    // Convert lamports to SOL
    const feeInSol = fee / solanaWeb3.LAMPORTS_PER_SOL;

    const signature = await solanaConnection.sendRawTransaction(
      transaction.serialize(),
      {
        skipPreflight: false,
        preflightCommitment: 'confirmed',
      },
    );

    // Optional: Wait for confirmation
    const confirmation = await solanaConnection.confirmTransaction({
      signature,
      blockhash: blockhash,
      lastValidBlockHeight: lastValidBlockHeight,
    });

    if (confirmation.value.err) {
      throw new Error(`Transaction failed: ${confirmation.value.err}`);
    }
    console.log({ signature });

    return signature;
  } catch (error) {
    console.error('Failed to build and send transaction:', error);
    throw error;
  }
}

(async () => {
  await getQuote();
})();

Previous
Token list and search

Charging Fees with Bungee
Bungee allows integrators to charge fees on swaps and transfers, providing a revenue stream for your application. This guide explains how to implement fee charging in both Bungee Auto and Bungee Manual integrations.

If you plan to implement fee charging, please request a dedicated API key first.

Fee Mechanics
API Reference: Quote

When integrating Bungee, you can specify two key parameters to collect fees:

feeTakerAddress: The address that will receive the collected fees
feeBps: The percentage of the transfer amount to charge as a fee (in basis points - 1 basis point = 0.01%)
These parameters ensure that a portion of each swap is directed to your specified feeTaker address. The input token amount will be reduced by the fee amount before the swap is executed.

Implementation
You can add fee parameters to both Bungee Auto and Manual integrations when requesting a quote:

/**
 * This example demonstrates how to implement fee charging in a Bungee integration
 */

// Configuration
const BUNGEE_API_BASE_URL = "https://public-backend.bungee.exchange";

/**
 * Get a quote with fee parameters
 * @param {Object} params - The parameters for the quote request
 * @returns {Promise<Object>} The quote response
 */
async function getQuoteWithFees() {
  // Set up the parameters for the quote request
  const quoteParams = {
    userAddress: "0xYourUsersAddress",
    originChainId: "1", // Ethereum
    destinationChainId: "10", // Optimism
    inputToken: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC on Ethereum
    outputToken: "0x7F5c764cBc14f9669B88837ca1490cCa17c31607", // USDC on Optimism
    inputAmount: "1000000", // 1 USDC (6 decimals)
    receiverAddress: "0xYourUsersAddress",
    feeTakerAddress: "0xYourFeeCollectionAddress", // Address to receive fees
    feeBps: "50", // 0.5% fee (50 basis points)
  };

  // For Manual mode, add this parameter
  // quoteParams.enableManual = "true";

  // Build the URL with query parameters
  const url = `${BUNGEE_API_BASE_URL}/api/v1/bungee/quote`;
  const queryParams = new URLSearchParams(quoteParams);
  const fullUrl = `${url}?${queryParams}`;

  // Make the request
  const response = await fetch(fullUrl, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
  });

  const data = await response.json();
  const serverReqId = response.headers.get("server-req-id");

  if (!data.success) {
    throw new Error(
      `Quote error: ${data.statusCode}: ${data.message}. server-req-id: ${serverReqId}`
    );
  }

  return data.result;
}

Bungee Auto API Reference
The Bungee Auto API provides endpoints for integrating swaps into your application.

API Endpoints
Bungee provides three different API endpoints to suit different use cases:

Public Endpoint
https://public-backend.bungee.exchange

Rate Limit: 20 requests per minute (RPM) per IP address
Authentication: None required
Use Case: Development and testing
Access: Open to all
Versioning
All endpoints are versioned using the /api/v1 prefix in the path. For example:

https://public-backend.bungee.exchange/api/v1/bungee/quote

Requesting Production API Access
For production use with higher rate limits or domain whitelisting, please fill out the Bungee API Access Request Form to request dedicated API keys and access to our production endpoints.

Production API Endpoints (Click to Expand)
Available Endpoints
Endpoint	Description
/api/v1/supported-chains	Get a list of supported chains
/api/v1/tokens/list	Get a list of available tokens
/api/v1/tokens/search	Search for specific tokens
/api/v1/bungee/quote	Get pricing information for swaps
/api/v1/bungee/submit	Submit swap requests
/api/v1/bungee/build-tx	Build transaction data for Bungee Manual
/api/v1/bungee/status	Check the status of submitted requests
Server Request ID
All responses include a server-req-id header that can be used for debugging purposes when contacting support. When encountering any errors or unexpected behavior:

Always capture and log this ID along with the error details
Include this ID when reporting issues to the Bungee team
Add the ID to any error messages shown to users to facilitate troubleshooting
Example of capturing the server-req-id in error handling:

async function getQuote(params) {
  const url = `${BUNGEE_API_BASE_URL}/api/v1/bungee/quote`;
  const queryParams = new URLSearchParams(params);
  const queryUrl = `${url}?${queryParams}`;
  const response = await fetch(queryUrl);
  const data = await response.json();
  const serverReqId = response.headers.get("server-req-id");

  if (!data.success) {
    throw new Error(
      `Quote error: ${data.statusCode}: ${data.message}. server-req-id: ${serverReqId}`
    );
  }

  return data.result;
}

The server-req-id provides the Bungee team with crucial information to trace the exact request through their systems, significantly improving debugging efficiency and resolution time.

Get token list
GET
/api/v1/tokens/list
Get token list

Request
Query Parameters
userAddress
string
User wallet address

chainIds
string
Comma separate chainIds

list
string
Set the list type you want: full or trending

Default value: trending
Responses
200
Returns the list of tokens by chain. This is not a complete list of supported tokens.

application/json
Schema
Example (auto)
Schema
success
boolean
required
flag indicating whether the req was successful

Default value: true
statusCode
number
required
Http status code

Default value: 200
result
object
required
curl
nodejs
go
python
AXIOS
NATIVE
const axios = require('axios');

let config = {
  method: 'get',
  maxBodyLength: Infinity,
  url: 'https://public-backend.bungee.exchange/api/v1/tokens/list',
  headers: { 
    'Accept': 'application/json'
  }
};

axios.request(config)
.then((response) => {
  console.log(JSON.stringify(response.data));
})
.catch((error) => {
  console.log(error);
});



Request
Collapse all
Parameters
Send API Request
Response
Clear
Click the Send API Request button above and see the response here!

Get all supported chains
GET
/api/v1/supported-chains
Get all supported chains

Request
Responses
200
Retrieve all supported chains and their details

application/json
Schema
Example (auto)
Schema
success
boolean
required
flag indicating whether the req was successful

Default value: true
statusCode
number
required
Http status code

Default value: 200
result
object[]

Search or import tokens
GET
/api/v1/tokens/search
Search or import tokens

Request
Query Parameters
q
string
required
Search query for token address, name or symbol. Does partial matching too

Example: ETH
userAddress
string
User wallet address

Example: 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
Responses
200
Returns the list of tokens with that query by chain.

application/json
Schema
Example (auto)
Schema
success
boolean
required
flag indicating whether the req was successful

Default value: true
statusCode
number
required
Http status code

Default value: 200
result
object
required
curl
nodejs
go
python
AXIOS
NATIVE
const https = require('follow-redirects').https;
const fs = require('fs');

let options = {
  'method': 'GET',
  'hostname': 'public-backend.bungee.exchange',
  'path': '/api/v1/tokens/search',
  'headers': {
    'Accept': 'application/json'
  },
  'maxRedirects': 20
};

const req = https.request(options, (res) => {
  let chunks = [];

  res.on("data", (chunk) => {
    chunks.push(chunk);
  });

  res.on("end", (chunk) => {
    let body = Buffer.concat(chunks);
    console.log(body.toString());
  });

  res.on("error", (error) => {
    console.error(error);
  });
});

req.end();


Request
Collapse all
Parameters
q â€” queryrequired
ETH
Send API Request
Response
Clear
Click the Send API Request button above and see the response here!

Get Bungee quote
GET
/api/v1/bungee/quote
Get Bungee quote

Request
Query Parameters
userAddress
string
required
Sender wallet address

Example: 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
originChainId
string
required
Source Chain Id

Example: 42161
destinationChainId
string
required
Destination Chain Id

Example: 10
inputToken
string
required
Address of the input token

Example: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
inputAmount
string
required
Input amount in wei

Example: 100000000000000
receiverAddress
string
required
Receiver wallet address

Example: 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
outputToken
string
required
Output token address

Example: 0x0b2c639c533813f4aa9d7837caf62653d097ff85
slippage
string
Swap slippage for manual routes and slippage considered for auto route

delegateAddress
string
Delegate address applied to routes where delegate is an option. By default set to userAddress

refuel
string
Apply refuel to the request. Refuel by default is false

destinationPayload
string
Destination payload to execute on the receiver. Destination gas limit needed along with this param if set

destinationGasLimit
string
Destination gas limit to be used to execute the payload on destination receiver

feeBps
string
Fee in bps

feeTakerAddress
string
Address to collect fee

enableManual
string
Enable manual routes. By default it is false

disableSwapping
string
disable swapping for manual routes. By default it is false

disableAuto
string
disable auto routes. By default it is false

excludeBridges
string
Bridges to exclude in manual routes. Only applicable to manual routes

includeDexes
string
Dexes to include while routing via manual routes. Only applicable to manual

excludeDexes
string
Dexes to exclude in manual routes. Only applicable to manual routes

includeBridges
string
Bridges to include while routing via manual routes. Only applicable to manual

exclusiveTransmitter
string
exclusive requests can be sent by putting in an identifier address of the transmitter

useInbox
string
use inbox to send request to the inbox. By default it is false, Only applicable to auto routes

Responses
200
Bungee quote response for a same-chain or cross-chain swap

application/json
Schema
Example (auto)
ethExample
usdcExample
Schema
success
boolean
required
flag indicating whether the req was successful

Default value: true
statusCode
number
required
Http status code

Default value: 200
result
object
required
curl
nodejs
go
python
AXIOS
NATIVE
const https = require('follow-redirects').https;
const fs = require('fs');

let options = {
  'method': 'GET',
  'hostname': 'public-backend.bungee.exchange',
  'path': '/api/v1/bungee/quote',
  'headers': {
    'Accept': 'application/json'
  },
  'maxRedirects': 20
};

const req = https.request(options, (res) => {
  let chunks = [];

  res.on("data", (chunk) => {
    chunks.push(chunk);
  });

  res.on("end", (chunk) => {
    let body = Buffer.concat(chunks);
    console.log(body.toString());
  });

  res.on("error", (error) => {
    console.error(error);
  });
});

req.end();


Request
Collapse all
Parameters
userAddress â€” queryrequired
0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
originChainId â€” queryrequired
42161
destinationChainId â€” queryrequired
10
inputToken â€” queryrequired
0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
inputAmount â€” queryrequired
100000000000000
receiverAddress â€” queryrequired
0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
outputToken â€” queryrequired
0x0b2c639c533813f4aa9d7837caf62653d097ff85
Send API Request
Response
Clear
Click the Send API Request button above and see the response here!