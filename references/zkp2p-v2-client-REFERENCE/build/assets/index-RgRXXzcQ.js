function y(e){return new TextEncoder().encode(e)}function l(e){const n=new Uint8Array(e);let t="";for(const i of n)t+=String.fromCharCode(i);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function b(e){const n=e.replace(/-/g,"+").replace(/_/g,"/"),t=(4-n.length%4)%4,r=n.padEnd(n.length+t,"="),i=atob(r),s=new ArrayBuffer(i.length),o=new Uint8Array(s);for(let u=0;u<i.length;u++)o[u]=i.charCodeAt(u);return s}function g(){return window?.PublicKeyCredential!==void 0&&typeof window.PublicKeyCredential=="function"}function E(e){const{id:n}=e;return{...e,id:b(n),transports:e.transports}}function A(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class a extends Error{constructor({message:n,code:t,cause:r,name:i}){super(n,{cause:r}),this.name=i??r.name,this.code=t}}function _({error:e,options:n}){const{publicKey:t}=n;if(!t)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(n.signal instanceof AbortSignal)return new a({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(t.authenticatorSelection?.requireResidentKey===!0)return new a({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.authenticatorSelection?.userVerification==="required")return new a({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new a({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new a({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return t.pubKeyCredParams.filter(i=>i.type==="public-key").length===0?new a({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new a({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const r=window.location.hostname;if(A(r)){if(t.rp.id!==r)return new a({message:`The RP ID "${t.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new a({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(t.user.id.byteLength<1||t.user.id.byteLength>64)return new a({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new a({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class I{createNewAbortSignal(){if(this.controller){const t=new Error("Cancelling existing WebAuthn API call for new one");t.name="AbortError",this.controller.abort(t)}const n=new AbortController;return this.controller=n,n.signal}cancelCeremony(){if(this.controller){const n=new Error("Manually cancelling existing WebAuthn API call");n.name="AbortError",this.controller.abort(n),this.controller=void 0}}}const p=new I,P=["cross-platform","platform"];function m(e){if(e&&!(P.indexOf(e)<0))return e}async function D(e){if(!g())throw new Error("WebAuthn is not supported in this browser");const t={publicKey:{...e,challenge:b(e.challenge),user:{...e.user,id:y(e.user.id)},excludeCredentials:e.excludeCredentials?.map(E)}};t.signal=p.createNewAbortSignal();let r;try{r=await navigator.credentials.create(t)}catch(c){throw _({error:c,options:t})}if(!r)throw new Error("Registration was not completed");const{id:i,rawId:s,response:o,type:u}=r;let d;typeof o.getTransports=="function"&&(d=o.getTransports());let w;if(typeof o.getPublicKeyAlgorithm=="function")try{w=o.getPublicKeyAlgorithm()}catch(c){R("getPublicKeyAlgorithm()",c)}let f;if(typeof o.getPublicKey=="function")try{const c=o.getPublicKey();c!==null&&(f=l(c))}catch(c){R("getPublicKey()",c)}let h;if(typeof o.getAuthenticatorData=="function")try{h=l(o.getAuthenticatorData())}catch(c){R("getAuthenticatorData()",c)}return{id:i,rawId:l(s),response:{attestationObject:l(o.attestationObject),clientDataJSON:l(o.clientDataJSON),transports:d,publicKeyAlgorithm:w,publicKey:f,authenticatorData:h},type:u,clientExtensionResults:r.getClientExtensionResults(),authenticatorAttachment:m(r.authenticatorAttachment)}}function R(e,n){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,n)}function T(e){return new TextDecoder("utf-8").decode(e)}function C(){const e=window.PublicKeyCredential;return e.isConditionalMediationAvailable===void 0?new Promise(n=>n(!1)):e.isConditionalMediationAvailable()}function S({error:e,options:n}){const{publicKey:t}=n;if(!t)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(n.signal instanceof AbortSignal)return new a({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new a({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const r=window.location.hostname;if(A(r)){if(t.rpId!==r)return new a({message:`The RP ID "${t.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new a({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new a({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function O(e,n=!1){if(!g())throw new Error("WebAuthn is not supported in this browser");let t;e.allowCredentials?.length!==0&&(t=e.allowCredentials?.map(E));const r={...e,challenge:b(e.challenge),allowCredentials:t},i={};if(n){if(!await C())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');i.mediation="conditional",r.allowCredentials=[]}i.publicKey=r,i.signal=p.createNewAbortSignal();let s;try{s=await navigator.credentials.get(i)}catch(h){throw S({error:h,options:i})}if(!s)throw new Error("Authentication was not completed");const{id:o,rawId:u,response:d,type:w}=s;let f;return d.userHandle&&(f=T(d.userHandle)),{id:o,rawId:l(u),response:{authenticatorData:l(d.authenticatorData),clientDataJSON:l(d.clientDataJSON),signature:l(d.signature),userHandle:f},type:w,clientExtensionResults:s.getClientExtensionResults(),authenticatorAttachment:m(s.authenticatorAttachment)}}function K(){return g()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(e=>e(!1))}export{p as WebAuthnAbortService,a as WebAuthnError,b as base64URLStringToBuffer,g as browserSupportsWebAuthn,C as browserSupportsWebAuthnAutofill,l as bufferToBase64URLString,K as platformAuthenticatorIsAvailable,O as startAuthentication,D as startRegistration};
