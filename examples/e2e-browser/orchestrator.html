<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ZKP2P Orchestrator Demo</title>
    <style>
      body { font-family: -apple-system, system-ui, sans-serif; padding: 16px; }
      button { margin-right: 8px; padding: 8px 12px; }
      pre { background: #111; color: #eee; padding: 12px; border-radius: 6px; }
    </style>
  </head>
  <body>
    <h1>ZKP2P Orchestrator Demo (Revolut)</h1>
    <p>
      This example shows how to list Revolut payments via the extension and generate a proof using the
      SDK orchestrator. Make sure the extension is installed and you run a local server (same-origin).
    </p>
    <p>
      <button id="btn-payments">Fetch Revolut Payments</button>
      <button id="btn-proof" disabled>Generate Proof (first payment)</button>
    </p>
    <pre id="log"></pre>

    <script type="module">
      import { intentHashHexToDecimalString } from '../../packages/client-sdk/dist/index.mjs';
      import { ExtensionOrchestrator } from '../../packages/client-sdk/dist/extension.mjs';

      const logEl = document.getElementById('log');
      const log = (...args) => {
        const line = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
        logEl.textContent += line + '\n';
      };

      const orch = new ExtensionOrchestrator({ debug: true, versionPollMs: 3000 });
      const btnPayments = document.getElementById('btn-payments');
      const btnProof = document.getElementById('btn-proof');

      let payments = [];
      let selected;

      btnPayments.onclick = async () => {
        log('Requesting Revolut payments...');
        try {
          payments = await orch.requestAndGetPayments('revolut');
          log('Got payments:', payments.length);
          if (payments.length) {
            selected = payments[0];
            log('Selected first payment:', selected);
            btnProof.disabled = false;
          }
        } catch (e) {
          log('Error fetching payments:', e.message || e);
        }
      };

      btnProof.onclick = async () => {
        if (!selected) return;
        try {
          // Fake an intent hash for demo (32-byte zero); in a real app this comes from on-chain intent
          const intentHashHex = '0x' + '00'.repeat(32);
          const proofs = await orch.generateProofs('revolut', intentHashHex, selected.originalIndex);
          log('Generated proofs:', proofs.length);
          const bytes = orch.buildProofBytes(proofs);
          log('Proof bytes length:', bytes.length);
        } catch (e) {
          log('Error generating proof:', e.message || e);
        }
      };
    </script>
  </body>
  </html>

